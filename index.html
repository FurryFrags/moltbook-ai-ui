<!doctype html>
<html>
<head>
<meta charset="utf-8"/>
<title>MoltBook — Ashen Portal (Agent + Browser)</title>
<style>
  :root{--bg:#0f0f10;--panel:#111;--muted:#888;--accent:#1f6feb;--border:#232326}
  body{font-family:Inter,system-ui,sans-serif;margin:0;background:var(--bg);color:#eee}
  #app{display:grid;grid-template-columns:260px minmax(0,1fr);gap:14px;padding:14px;height:100vh;box-sizing:border-box;position:relative}
  .panel{background:var(--panel);border-radius:14px;padding:14px;overflow:auto;border:1px solid #1c1c20}
  .panel h3{margin:0 0 8px 0}
  #chatSidebar{display:flex;flex-direction:column;gap:10px}
  #chatList{display:flex;flex-direction:column;gap:8px;overflow:auto;padding-right:4px}
  .chat-item{padding:10px;border:1px solid #2a2f3a;background:#141418;border-radius:10px;cursor:pointer;text-align:left;color:#d7dceb}
  .chat-item.active{border-color:#2f6dd1;background:#101c35}
  .chat-item-title{font-weight:600;font-size:13px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
  .chat-item-meta{font-size:11px;color:#9aa3b7;margin-top:4px}
  .controls{display:flex;gap:6px;flex-wrap:wrap}
  #messages{max-height:34vh;overflow:auto;padding-right:4px}
  .msg{padding:10px 12px;border-radius:14px;margin:6px 0;word-break:break-word;line-height:1.4;max-width:82%}
  .msg.user{margin-left:auto;background:#1a2a48;border:1px solid #35578f}
  .msg.ashen{margin-right:auto;background:#171717;border:1px solid #2b2b2f}
  .msg details.msg-section{margin-top:8px;border:1px solid #2a2f3a;border-radius:10px;background:#101216;overflow:hidden}
  .msg details.msg-section summary{cursor:pointer;padding:8px 10px;font-size:12px;font-weight:600;color:#a9c4ff;user-select:none}
  .msg details.msg-section .msg-section-body{padding:0 10px 10px 10px;font-size:12px;color:#cfd6e6;white-space:pre-wrap}
  .msg.system,.msg.error{max-width:100%;background:#0b0b0b;border:1px solid #26262d;color:#ddd}
  input[type=text],input[type=password],textarea{width:100%;padding:10px;background:#0b0b0b;border:1px solid #25252a;color:#eee;border-radius:12px;box-sizing:border-box}
  #input{min-height:64px;max-height:180px;line-height:1.4;resize:vertical}
  button{background:var(--accent);color:#fff;border:none;padding:8px 10px;border-radius:10px;cursor:pointer;font-weight:600}
  button:disabled{opacity:.65;cursor:not-allowed}
  .tab{padding:9px 12px;border-radius:10px 10px 0 0;background:#17171b;cursor:pointer;min-width:180px;max-width:300px;border:1px solid #26262d;border-bottom:none;display:inline-block;vertical-align:bottom}
  .tab.active{background:#0b0b0b;border-color:#2f6dd1;box-shadow:inset 0 -2px 0 #2f6dd1}
  .tabs-strip{display:flex;gap:6px;overflow:auto;padding:6px 6px 0 6px;background:#141418;border-radius:10px 10px 0 0;border:1px solid var(--border);border-bottom:none}
  .tabs-actionbar{display:flex;gap:6px;padding:8px;background:#141418;border:1px solid var(--border);border-top:none;border-bottom:none}
  .tabs-window-launch{margin-top:8px}
  .console{font-family:monospace;font-size:12px;background:#060606;padding:8px;border-radius:8px;height:40vh;overflow:auto;border:1px solid #1f1f24}
  .small{font-size:12px;color:#aaa}
  #replyArea{display:flex;flex-direction:column;gap:8px;overflow:auto;padding:8px 4px;flex:1;min-height:0}
  #tabContent{white-space:pre-wrap;padding:12px;background:#060606;border-radius:0 0 8px 8px;max-height:39vh;overflow:auto;font-family:monospace;font-size:13px;border:1px solid var(--border)}
  #embedContainer{width:100%;height:320px;background:#000;border-radius:8px;overflow:hidden;position:relative;border:1px solid #202026}
  iframe.embed{width:100%;height:100%;border:0;display:block}
  .embed-controls{display:flex;gap:8px;margin-top:8px}
  .embed-mode-note{font-size:12px;color:#8ecbff;margin-top:6px}
  label.switch{display:flex;gap:8px;align-items:center;cursor:pointer}
  input[type=checkbox]{width:16px;height:16px}
  #evidenceList{margin-top:8px;background:#0b0b0b;padding:8px;border-radius:8px;font-family:monospace;font-size:13px;max-height:22vh;overflow:auto;border:1px solid #1f1f24}
  .evidence-item{padding:8px;border-radius:6px;margin-bottom:8px;background:#070707}
  .evidence-title{font-weight:600;color:#9ad;margin-bottom:6px}
  .small-muted{font-size:12px;color:#888}
  .answer-meta{margin-top:8px;font-size:12px;color:#9bc}
  .answer-warn{color:#ffb86b}
  .answer-ok{color:#9be39b}
  .status-pill{font-size:12px;color:#8ecbff;padding:2px 0 0 2px}
  #center{display:flex;flex-direction:column;overflow:hidden}
  .chat-shell{display:flex;flex-direction:column;gap:10px;background:#121214;border:1px solid #22252b;border-radius:18px;padding:10px;flex:1;min-height:0}
  .chat-composer{display:flex;gap:8px;align-items:flex-end;background:#16181d;border:1px solid #2a2f3a;border-radius:18px;padding:10px}
  .below-chat-dropdown{margin-top:10px;background:#121214;border:1px solid #22252b;border-radius:14px;overflow:hidden}
  .below-chat-dropdown summary{cursor:pointer;list-style:none;padding:12px 14px;font-weight:600;user-select:none}
  .below-chat-dropdown summary::-webkit-details-marker{display:none}
  .below-chat-dropdown summary::after{content:'▾';float:right;color:#9aa3b7;transition:transform .2s ease}
  .below-chat-dropdown:not([open]) summary::after{transform:rotate(-90deg)}
  .below-chat{padding:0 10px 10px 10px;display:flex;flex-direction:column;gap:8px;max-height:34vh;overflow:auto;border-top:1px solid #22252b}
  .inline-row{display:flex;gap:6px;align-items:center}
  .inline-row input[type=text],.inline-row input[type=password]{flex:1}
  .compact-title{margin:0;font-size:14px}
  .drawer-toggle{position:absolute;top:14px;right:14px;z-index:15}
  #right{position:absolute;right:14px;top:58px;bottom:14px;width:340px;z-index:20;transition:transform .25s ease,opacity .25s ease;box-shadow:0 6px 24px rgba(0,0,0,.45)}
  #right.closed{transform:translateX(380px);opacity:0;pointer-events:none}
  #closeDrawer{background:#333}
</style>
</head>
<body>
<div id="app">
  <button class="drawer-toggle" id="toggleDrawer">Logs & Console</button>

  <div class="panel" id="chatSidebar">
    <h3>Chats</h3>
    <button id="newChatBtn">New Chat</button>
    <div id="chatList"></div>
  </div>

  <div class="panel" id="center">
    <h3>Ashen Chat</h3>
    <div class="chat-shell">
      <div id="replyArea"></div>
      <div class="chat-composer">
        <textarea id="input" placeholder="Message Ashen..."></textarea>
        <button id="sendBtn">Send</button>
      </div>
      <div id="chatStatus" class="status-pill"></div>
    </div>
    <details class="below-chat-dropdown">
      <summary>Quick controls</summary>
      <div class="below-chat">
      <div class="small">Password (required)</div>
      <input id="pw" type="password" placeholder="Password"/>
      <label class="switch"><input id="liveMode" type="checkbox"/> Live internet mode</label>
      <div class="inline-row">
        <input id="liveSeconds" type="text" value="120" placeholder="seconds" />
        <button id="browseNowBtn">Browse now</button>
      </div>
      <div class="inline-row">
        <input id="openUrl" type="text" placeholder="https://example.com"/>
        <button id="openBtn">Open</button>
      </div>
      <button id="openTabsWindow" class="tabs-window-launch">Open Large Tabs Window</button>
      <div id="evidenceList">No web evidence yet. Ashen will decide when research is needed.</div>
      <div id="embedContainer" style="display:none"></div>
      <div id="tabContent">No tab selected.</div>
      <div style="display:none">
        <div class="tabs-strip" id="tabsList"></div>
        <div class="tabs-actionbar">
          <button id="refreshTabs">Refresh Tabs</button>
          <button id="fetchTab">Fetch</button>
          <button id="summTab">Summarize</button>
          <button id="closeTab">Close</button>
        </div>
      </div>
      </div>
    </details>
  </div>

  <div class="panel closed" id="right">
    <div class="controls" style="justify-content:space-between;align-items:center">
      <h3 style="margin:0">Logs Sidebar</h3>
      <button id="closeDrawer">Close</button>
    </div>
    <div class="small">Conversation log</div>
    <div id="messages"></div>

    <h3 style="margin-top:12px">Console</h3>
    <div class="console" id="console"></div>
  </div>
</div>

<!-- SoundCloud widget API will be injected when needed -->
<script>
const WORKER_URL = "https://ashen.furryfrags.workers.dev"; // change to your worker URL
const pwEl = document.getElementById('pw');
const inputEl = document.getElementById('input');
const sendBtn = document.getElementById('sendBtn');
const openBtn = document.getElementById('openBtn');
const openUrl = document.getElementById('openUrl');
const messagesDiv = document.getElementById('messages');
const replyArea = document.getElementById('replyArea');
const chatListEl = document.getElementById('chatList');
const newChatBtn = document.getElementById('newChatBtn');
const tabContentDiv = document.getElementById('tabContent');
const embedContainer = document.getElementById('embedContainer');
const tabsList = document.getElementById('tabsList');
const consoleDiv = document.getElementById('console');
const refreshTabsBtn = document.getElementById('refreshTabs');
const fetchTabBtn = document.getElementById('fetchTab');
const summTabBtn = document.getElementById('summTab');
const closeTabBtn = document.getElementById('closeTab');
const openTabsWindowBtn = document.getElementById('openTabsWindow');
const evidenceList = document.getElementById('evidenceList');
const liveMode = document.getElementById('liveMode');
const liveSeconds = document.getElementById('liveSeconds');
const browseNowBtn = document.getElementById('browseNowBtn');
const chatStatus = document.getElementById('chatStatus');
const rightDrawer = document.getElementById('right');
const toggleDrawerBtn = document.getElementById('toggleDrawer');
const closeDrawerBtn = document.getElementById('closeDrawer');

let selectedTabId = null;
let lastTabs = [];
let lastTabsSignature = "";
const liveTabMetaKeys = new Map();
const renderedTabKeys = new Map();
let scWidget = null; // SoundCloud widget instance
let liveTimer = null;
let liveInFlight = false;
let liveFailureCount = 0;
let liveBackoffUntil = 0;
let embedFallbackTimer = null;
let cleanupUniversalEmbed = null;
let activeChatController = null;
let chatInFlight = false;
let tabsWindow = null;
let tabsWindowReady = false;
let chats = [];
let activeChatId = null;
const DEFAULT_MESSAGE_RENDER_LIMIT = 50;
const messageRenderState = {
  replyArea: DEFAULT_MESSAGE_RENDER_LIMIT,
  messages: DEFAULT_MESSAGE_RENDER_LIMIT
};
const CHAT_STORAGE_KEY = 'ashen-chat-sessions-v1';
const CHAT_RETENTION = {
  maxChats: 80,
  maxMessagesPerChat: 120,
  maxCharsPerMessage: 4000
};

const TRUSTED_NEWS_DOMAINS = [
  'apnews.com','reuters.com','bbc.com','cnn.com','nytimes.com','washingtonpost.com','theguardian.com',
  'npr.org','pbs.org','abcnews.go.com','cbsnews.com','nbcnews.com','bloomberg.com','wsj.com',
  'aljazeera.com','france24.com','dw.com','elpais.com','lemonde.fr','usatoday.com'
];

function safeParseUrl(url) {
  const value = String(url || '').trim();
  if (!value) return null;
  const normalized = value.startsWith('//') ? `https:${value}` : value;
  try { return new URL(normalized); } catch { return null; }
}

function normalizeEvidenceUrl(rawUrl) {
  const cleaned = cleanEvidenceText(rawUrl);
  const parsed = safeParseUrl(cleaned);
  if (!parsed) return cleaned;
  const isDdgRedirect = /duckduckgo\.com$/i.test(parsed.hostname) && parsed.pathname.startsWith('/l/');
  if (!isDdgRedirect) return cleaned;
  const embedded = parsed.searchParams.get('uddg');
  if (!embedded) return cleaned;
  try {
    return decodeURIComponent(embedded);
  } catch {
    return embedded;
  }
}

function domainFromUrl(rawUrl) {
  const parsed = safeParseUrl(rawUrl);
  return parsed ? parsed.hostname.toLowerCase() : '';
}

function isTrustedDomain(hostname) {
  return TRUSTED_NEWS_DOMAINS.some(d => hostname === d || hostname.endsWith(`.${d}`));
}

function roleClass(who) {
  const normalized = String(who || '').toLowerCase();
  if (normalized === 'you') return 'user';
  if (normalized === 'ashen') return 'ashen';
  if (normalized === 'error') return 'error';
  return 'system';
}

function makeChat(title = 'New Chat', messages = []) {
  return {
    id: (crypto?.randomUUID ? crypto.randomUUID() : `chat-${Date.now()}-${Math.random().toString(16).slice(2)}`),
    title,
    createdAt: new Date().toISOString(),
    updatedAt: new Date().toISOString(),
    messages,
    archived: false
  };
}

function archiveActiveChatToPrevious() {
  const active = getActiveChat();
  if (!active || !(active.messages || []).length) return;
  active.archived = true;
  active.updatedAt = new Date().toISOString();
}

function normalizeChat(chat) {
  const now = new Date().toISOString();
  return {
    ...chat,
    id: chat?.id || (crypto?.randomUUID ? crypto.randomUUID() : `chat-${Date.now()}-${Math.random().toString(16).slice(2)}`),
    title: chat?.title || 'New Chat',
    createdAt: chat?.createdAt || chat?.updatedAt || now,
    updatedAt: chat?.updatedAt || chat?.createdAt || now,
    archived: Boolean(chat?.archived),
    messages: Array.isArray(chat?.messages) ? chat.messages : []
  };
}

function pruneChatsForRetention(sourceChats, preferredActiveId = null) {
  const normalized = (Array.isArray(sourceChats) ? sourceChats : []).map((chat) => {
    const safeChat = normalizeChat(chat);
    safeChat.messages = safeChat.messages
      .slice(-CHAT_RETENTION.maxMessagesPerChat)
      .map((entry) => ({
        who: String(entry?.who || 'System'),
        text: String(entry?.text || '').slice(0, CHAT_RETENTION.maxCharsPerMessage)
      }));
    return safeChat;
  });

  const deduped = [];
  const seen = new Set();
  normalized.forEach((chat) => {
    if (!chat.id || seen.has(chat.id)) return;
    seen.add(chat.id);
    deduped.push(chat);
  });

  deduped.sort((a, b) => new Date(b.updatedAt) - new Date(a.updatedAt));
  let retained = deduped.slice(0, CHAT_RETENTION.maxChats);
  if (!retained.length) retained = [makeChat('New Chat', [])];

  let nextActiveId = preferredActiveId;
  if (!retained.some((chat) => chat.id === nextActiveId)) {
    const latestUnarchived = retained.find((chat) => !chat.archived);
    nextActiveId = (latestUnarchived || retained[0]).id;
  }

  return { chats: retained, activeChatId: nextActiveId };
}

function persistChats() {
  const retained = pruneChatsForRetention(chats, activeChatId);
  chats = retained.chats;
  activeChatId = retained.activeChatId;
  localStorage.setItem(CHAT_STORAGE_KEY, JSON.stringify({ chats, activeChatId }));
}

function getActiveChat() {
  return chats.find((chat) => chat.id === activeChatId) || null;
}

function updateChatTitle(chat) {
  const userEntry = (chat.messages || []).find((entry) => String(entry.who || '').toLowerCase() === 'you');
  if (!userEntry || chat.title !== 'New Chat') return;
  chat.title = String(userEntry.text || '').trim().slice(0, 42) || 'New Chat';
}

function formatMessageHtml(entry) {
  const who = String(entry?.who || '');
  const text = String(entry?.text || '');
  const baseLabel = `<b>${escapeHtml(who)}:</b>`;
  if (who.toLowerCase() !== 'ashen') {
    return `${baseLabel} ${escapeHtml(text).replace(/\n/g, '<br/>')}`;
  }

  const lines = text.split(/\r?\n/);
  const sections = [];
  let current = { type: 'main', title: '', lines: [] };

  for (const line of lines) {
    const trimmed = line.trim();
    const lower = trimmed.toLowerCase();
    if (lower === 'evidence highlights:' || lower === 'evidences:') {
      sections.push(current);
      current = { type: 'details', title: 'Evidences', lines: [] };
      continue;
    }
    if (lower === 'context gathered:' || lower === 'context:') {
      sections.push(current);
      current = { type: 'details', title: 'Context Gathered', lines: [] };
      continue;
    }
    current.lines.push(line);
  }
  sections.push(current);

  const main = sections.find((sec) => sec.type === 'main');
  const mainText = (main?.lines || []).join('\n').trim();
  const pieces = [baseLabel];
  if (mainText) {
    pieces.push(`<div>${escapeHtml(mainText).replace(/\n/g, '<br/>')}</div>`);
  }

  sections.filter((sec) => sec.type === 'details' && sec.lines.join('').trim()).forEach((sec) => {
    pieces.push(`<details class="msg-section"><summary>${escapeHtml(sec.title)}</summary><div class="msg-section-body">${escapeHtml(sec.lines.join('\n').trim())}</div></details>`);
  });

  return pieces.join('');
}

function renderMessageNode(entry) {
  const bubble = document.createElement('div');
  bubble.className = `msg ${roleClass(entry?.who)}`;
  bubble.innerHTML = formatMessageHtml(entry);
  return bubble;
}

function appendNewMessageToContainer(container, entry) {
  const stateKey = container.id;
  const active = getActiveChat();
  const totalMessages = (active?.messages || []).length;
  const hasLoadOlder = container.firstElementChild?.dataset?.loadOlder === 'true';
  const renderedMessages = hasLoadOlder ? container.children.length - 1 : container.children.length;
  const cap = messageRenderState[stateKey];
  if (renderedMessages >= cap) return false;

  if (!hasLoadOlder && totalMessages > cap) {
    renderMessageList(container, active?.messages || []);
    return true;
  }

  container.appendChild(renderMessageNode(entry));
  return true;
}

function createLoadOlderButton(container, remainingCount) {
  const btn = document.createElement('button');
  btn.type = 'button';
  btn.dataset.loadOlder = 'true';
  btn.textContent = `Load older (${remainingCount})`;
  btn.onclick = () => {
    messageRenderState[container.id] += DEFAULT_MESSAGE_RENDER_LIMIT;
    const active = getActiveChat();
    renderMessageList(container, active?.messages || []);
  };
  return btn;
}

function renderMessageList(container, entries) {
  const cap = messageRenderState[container.id] || DEFAULT_MESSAGE_RENDER_LIMIT;
  const startIndex = Math.max(0, entries.length - cap);
  const visibleEntries = entries.slice(startIndex);
  container.innerHTML = '';

  if (startIndex > 0) {
    container.appendChild(createLoadOlderButton(container, startIndex));
  }

  visibleEntries.forEach((entry) => {
    container.appendChild(renderMessageNode(entry));
  });
}

function renderReplyTranscript(forceFullRender = false) {
  const active = getActiveChat();
  const entries = active?.messages || [];

  if (forceFullRender) {
    messageRenderState.replyArea = DEFAULT_MESSAGE_RENDER_LIMIT;
    messageRenderState.messages = DEFAULT_MESSAGE_RENDER_LIMIT;
  }

  renderMessageList(replyArea, entries);
  replyArea.scrollTop = replyArea.scrollHeight;

  renderMessageList(messagesDiv, entries);
  messagesDiv.scrollTop = messagesDiv.scrollHeight;
}

function renderChatList() {
  chatListEl.innerHTML = '';
  chats.slice().sort((a, b) => new Date(b.updatedAt) - new Date(a.updatedAt)).forEach((chat) => {
    const item = document.createElement('button');
    item.className = `chat-item ${chat.id === activeChatId ? 'active' : ''}`;
    item.type = 'button';
    item.innerHTML = `
      <div class="chat-item-title">${escapeHtml(chat.title || 'New Chat')}</div>
      <div class="chat-item-meta">${(chat.messages || []).length} message${(chat.messages || []).length === 1 ? '' : 's'}</div>
    `;
    item.onclick = () => {
      activeChatId = chat.id;
      persistChats();
      renderChatList();
      renderReplyTranscript(true);
    };
    chatListEl.appendChild(item);
  });
}

function appendMsg(who,text){
  const active = getActiveChat();
  if (!active) return;
  const entry = { who, text: String(text || '') };
  active.messages.push(entry);
  active.updatedAt = new Date().toISOString();
  updateChatTitle(active);
  persistChats();
  renderChatList();
  const replyAppended = appendNewMessageToContainer(replyArea, entry);
  const logAppended = appendNewMessageToContainer(messagesDiv, entry);
  if (!replyAppended || !logAppended) {
    renderReplyTranscript();
  }
  replyArea.scrollTop = replyArea.scrollHeight;
  messagesDiv.scrollTop = messagesDiv.scrollHeight;
}

function initializeChats() {
  let loaded = null;
  try {
    loaded = JSON.parse(localStorage.getItem(CHAT_STORAGE_KEY) || 'null');
  } catch {
    loaded = null;
  }

  const retained = pruneChatsForRetention(loaded?.chats || [], loaded?.activeChatId);
  chats = retained.chats;
  activeChatId = retained.activeChatId;
  persistChats();

  renderChatList();
  renderReplyTranscript(true);
}

function escapeHtml(s){ return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }

function scoreEvidenceItem(item) {
  const normalizedUrl = normalizeEvidenceUrl(item?.url || '');
  const hostname = domainFromUrl(normalizedUrl);
  const t = `${item?.title || ''} ${item?.snippet || ''} ${item?.summary || ''}`.toLowerCase();
  let score = 0;
  if (normalizedUrl && /^https?:\/\//i.test(normalizedUrl)) score += 2;
  if (hostname && isTrustedDomain(hostname)) score += 3;
  if (/wikipedia\.org$/.test(hostname)) score -= 1;
  if (/according to|reported|confirmed|official|statement|issued on/.test(t)) score += 1;
  if (/400 bad request|returned an error 400|target url returning a bad request|status code 4\d\d|status code 5\d\d/.test(t)) score -= 4;
  if (/not accurate|cannot verify|unconfirmed|likely an error|rumor|fake|satire|denied/.test(t)) score -= 2;
  if (!hostname) score -= 1;
  return score;
}

function cleanEvidenceText(v) {
  return String(v || '').replace(/\s+/g, ' ').trim();
}

function isEvidenceBrokenText(text) {
  return /400 bad request|returned an error 400|status code 4\d\d|status code 5\d\d|no retrievable hits|not accessible due to/i.test(cleanEvidenceText(text));
}

function shouldRepairEvidenceItem(item) {
  const url = normalizeEvidenceUrl(item?.url || '');
  if (!url) return false;
  const brokenSummary = isEvidenceBrokenText(item?.summary || '');
  const brokenSnippet = isEvidenceBrokenText(item?.snippet || '');
  const parsed = safeParseUrl(url);
  const isDuckRedirect = parsed && /duckduckgo\.com$/i.test(parsed.hostname) && parsed.pathname.startsWith('/l/');
  return Boolean(brokenSummary || brokenSnippet || isDuckRedirect);
}

async function repairEvidence(evidence, pw) {
  const rows = Array.isArray(evidence) ? evidence.map((item) => ({ ...item })) : [];
  if (!rows.length || !pw) return rows;

  const repairCandidates = rows.filter(shouldRepairEvidenceItem).slice(0, 3);
  for (const item of repairCandidates) {
    const normalizedUrl = normalizeEvidenceUrl(item.url || '');
    if (!normalizedUrl) continue;

    const fetched = await callWorker({
      password: pw,
      command: {
        type: 'open_tab',
        url: normalizedUrl,
        fetchNow: true,
        summarizeAfter: true,
        words: 180
      },
      liveInternet: true,
      requestedAt: new Date().toISOString()
    });

    const tab = fetched?.tab;
    if (!tab) continue;

    const fetchedSummary = cleanEvidenceText(tab.summary || '');
    const fetchedContent = cleanEvidenceText((tab.content || '').slice(0, 320));
    if (!fetchedSummary && !fetchedContent) continue;

    item.url = tab.finalUrl || tab.url || normalizedUrl;
    item.title = tab.title || item.title;
    item.summary = fetchedSummary || item.summary;
    if (fetchedContent && !item.snippet) item.snippet = fetchedContent;
    item.sourceType = 'verified_fetch';
  }

  return rows;
}

function extractHttpUrls(text) {
  const matches = String(text || '').match(/https?:\/\/[^\s)\]>"']+/gi) || [];
  const seen = new Set();
  const urls = [];
  for (const raw of matches) {
    const normalized = normalizeEmbeddableUrl(raw);
    if (!normalized || seen.has(normalized)) continue;
    seen.add(normalized);
    urls.push(normalized);
  }
  return urls;
}

function isLikelyStatusUrl(url) {
  const parsed = safeParseUrl(url);
  if (!parsed) return false;
  const host = parsed.hostname.toLowerCase();
  return /(x\.com|twitter\.com|threads\.net)$/i.test(host) && /\/status\//i.test(parsed.pathname);
}

async function prefetchLinkedContext(text, pw) {
  const urls = extractHttpUrls(text).slice(0, 2);
  if (!urls.length) return '';

  const snippets = [];
  let loadedAny = false;

  for (const url of urls) {
    const needsStrongPrefetch = isLikelyStatusUrl(url);
    const res = await callWorker({
      password: pw,
      command: {
        type: 'open_tab',
        url,
        fetchNow: true,
        summarizeAfter: true,
        words: needsStrongPrefetch ? 220 : 140
      },
      liveInternet: true,
      requestedAt: new Date().toISOString()
    });

    if (res?.tab) {
      loadedAny = true;
      const summaryRaw = cleanEvidenceText(res.tab.summary || '');
      const hasSummary = Boolean(summaryRaw);
      const summary = hasSummary ? summaryRaw : 'No summary extracted.';
      const rawExcerpt = cleanEvidenceText((res.tab.content || '').slice(0, 260));
      const excerpt = hasSummary ? '' : rawExcerpt;
      snippets.push([
        `Source URL: ${res.tab.finalUrl || res.tab.url || url}`,
        `Title: ${cleanEvidenceText(res.tab.title || '(untitled)')}`,
        `Summary: ${summary}`,
        excerpt ? `Excerpt: ${excerpt}` : ''
      ].filter(Boolean).join('\n'));
    }

    if (res?.tabs) renderTabs(res.tabs);
    if (res?.console) renderConsole(res.console);
  }

  if (loadedAny) {
    renderTabsWindow();
    appendMsg('System', 'Read linked content first; using fetched page context for this reply.');
  }

  return snippets.join('\n\n---\n\n');
}

function isExplicitBrowsingRequest(text) {
  if (!text) return false;
  return /\b(browse|open|check|look up|verify|fact check|research)\b/i.test(text);
}

function isResearchIntentRequest(text) {
  if (!text) return false;
  return /\b(search|research|look up|latest|right now|rn|what happened|news|update)\b/i.test(text);
}

function parseResearchNeededSignal(reply) {
  const raw = String(reply || '').trim();
  if (!raw.startsWith('{') || !raw.endsWith('}')) return null;
  try {
    const parsed = JSON.parse(raw);
    return parsed?.researchNeeded === true ? parsed : null;
  } catch {
    return null;
  }
}

function consolidateEvidence(evidence) {
  const rows = (evidence || []).map((item) => {
    const score = scoreEvidenceItem(item);
    const title = cleanEvidenceText(item.title);
    const summary = cleanEvidenceText(item.summary || item.snippet);
    const url = normalizeEvidenceUrl(item.url);
    const hostname = domainFromUrl(url);
    const trusted = isTrustedDomain(hostname);
    const combined = `${title} ${summary}`.toLowerCase();
    const negatesClaim = /not accurate|not captured|denied|unconfirmed|false|no indication/.test(combined);
    const isBroken = /400 bad request|returned an error 400|status code 4\d\d|status code 5\d\d/.test(combined);
    return { score, title, summary, url, hostname, trusted, negatesClaim, isBroken };
  }).sort((a,b)=>b.score-a.score);

  const top = rows.slice(0, 5);
  const bullets = top.map((r, i) => `${i+1}. ${r.title || '(untitled)'} — ${r.summary || '(no summary)'}${r.url ? ` [${r.url}]` : ''}`);
  const cautionCount = top.filter(x => x.negatesClaim).length;
  const brokenCount = top.filter(x => x.isBroken).length;
  const trustedCount = top.filter(x => x.trusted).length;
  const meta = {
    selected: top.length,
    contradictionRisk: cautionCount > 0,
    lowReliability: brokenCount >= Math.max(2, Math.ceil(top.length / 2)) || trustedCount === 0,
    confidence: top.length ? Math.max(0, Math.min(100, 45 + top[0].score * 8 - cautionCount * 10 - brokenCount * 8)) : 0
  };
  return { bullets, meta, top };
}

function buildEvidenceBrief(evidence, maxItems = 5) {
  const rows = (evidence || []).slice(0, maxItems).map((item, idx) => {
    const title = cleanEvidenceText(item.title) || '(untitled)';
    const summary = cleanEvidenceText(item.summary || item.snippet) || '(no summary)';
    const url = normalizeEvidenceUrl(item.url) || '(no url)';
    return `${idx + 1}. ${title}\nURL: ${url}\nSummary: ${summary}`;
  });
  return rows.join('\n\n');
}

async function synthesizeGroundedAnswer({ question, draftReply, evidence, password, signal }) {
  if (!question || !evidence?.length) return '';
  const evidenceBrief = hardTruncateText(buildEvidenceBrief(evidence, 6), 5000);
  if (!evidenceBrief) return '';

  const synthesisPrompt = [
    'You are revising a response after web retrieval.',
    'Use the evidence below as the primary source of truth.',
    'If sources conflict, say so briefly and prefer the most direct/credible source.',
    'Do not mention training-data cutoffs when evidence is provided.',
    'Return only the final answer text (no JSON, no extra headings).',
    '',
    `User question: ${question}`,
    '',
    draftReply ? `Initial draft answer:\n${hardTruncateText(draftReply, 1800)}` : '',
    '',
    `Retrieved evidence:\n${evidenceBrief}`
  ].filter(Boolean).join('\n');

  const synthesisRes = await callWorker({
    password,
    message: synthesisPrompt,
    forceWeb: false,
    researchMode: 'off',
    liveInternet: false,
    styleProfile: 'grounded-brief-opinion',
    clientGuidance: {
      useProvidedEvidenceFirst: true,
      requireGroundedResearchForRealWorldClaims: true,
      avoidOverconfidenceOnWeakEvidence: true
    }
  }, { signal });

  if (synthesisRes?.error) return '';
  return cleanEvidenceText(synthesisRes?.reply || '');
}

function extractGroundedSummary(rows) {
  if (!rows || !rows.length) {
    return 'I could not find enough reliable web evidence to answer confidently.';
  }
  const primary = rows[0];
  const title = primary.title || (primary.hostname ? `Source on ${primary.hostname}` : 'Top retrieved source');
  const summary = primary.summary || 'No summary was available from the retrieved evidence.';
  const brokenCount = rows.filter(r => r.isBroken).length;
  const trustedCount = rows.filter(r => r.trusted).length;
  const caution = brokenCount > 0 || trustedCount === 0
    ? 'Retrieved evidence quality is mixed (broken links and/or weak sourcing), so this should be treated as tentative.'
    : '';
  return [
    `Based on the strongest retrieved evidence, ${title}: ${summary}`,
    caution
  ].filter(Boolean).join(' ');
}

function buildGroundedReply(rawReply, evidence) {
  const { bullets, meta, top } = consolidateEvidence(evidence);
  if (!bullets.length) return { text: rawReply || '', metaHtml: '' };

  const genericReply = /according to my training data|since my training data only goes up to|i don't have any information|i don't have the capability to browse|cannot browse/i.test(rawReply || '');
  const groundedSummary = extractGroundedSummary(top);
  const lead = (!genericReply && rawReply)
    ? String(rawReply || '').trim()
    : `Quick grounded take: ${groundedSummary}`;

  const contextLines = [];
  if (top[0]?.url) contextLines.push(`Primary source: ${top[0].url}`);
  if (top[0]?.summary) contextLines.push(`Top-source summary: ${top[0].summary}`);

  const combined = [
    lead,
    contextLines.length ? `\nContext Gathered:\n${contextLines.join('\n')}` : '',
    bullets.length ? `\nEvidences:\n${bullets.slice(0, 3).join('\n')}` : ''
  ].filter(Boolean).join('\n\n');

  const riskClass = (meta.contradictionRisk || meta.lowReliability || meta.confidence < 50) ? 'answer-warn' : 'answer-ok';
  const riskLabel = (meta.contradictionRisk || meta.lowReliability || meta.confidence < 50)
    ? 'Conflicting and/or low-quality evidence detected — treat claims as tentative.'
    : 'Evidence appears reasonably consistent.';

  const metaHtml = `<div class="answer-meta ${riskClass}">Confidence estimate: ${meta.confidence}% · ${riskLabel}</div>`;
  return { text: combined, metaHtml };
}

function estimateTokens(text) {
  return Math.ceil(String(text || '').length / 4);
}

function hardTruncateText(text, maxChars) {
  const normalized = String(text || '').replace(/\s+/g, ' ').trim();
  if (normalized.length <= maxChars) return normalized;
  return `${normalized.slice(0, Math.max(0, maxChars - 1))}…`;
}

function buildChatContextSnippet(chat, maxMessages = 8, maxChars = 1800, maxTokens = 450) {
  const entries = (chat?.messages || []).slice(-maxMessages);
  if (!entries.length) return '';
  const rows = [];
  let usedChars = 0;
  let usedTokens = 0;

  for (let i = entries.length - 1; i >= 0; i -= 1) {
    const entry = entries[i];
    const row = `${entry.who}: ${hardTruncateText(entry.text || '', 280)}`;
    const rowChars = row.length + 1;
    const rowTokens = estimateTokens(row);
    if (rows.length > 0 && (usedChars + rowChars > maxChars || usedTokens + rowTokens > maxTokens)) break;
    rows.unshift(row);
    usedChars += rowChars;
    usedTokens += rowTokens;
  }

  return rows.join('\n');
}

/**
 * Worker API command contract used by this UI:
 * - open_tab
 * - list_tabs
 * - fetch_tab
 * - check_tab_update (metadata-only live refresh check)
 * - summarize_tab
 * - close_tab
 */
async function callWorker(payload, options = {}){
  try {
    const headers = { 'Content-Type':'application/json' };
    const pw = pwEl.value;
    if (pw) headers['Authorization'] = 'Bearer ' + pw;
    const resp = await fetch(WORKER_URL, {
      method:'POST',
      headers,
      body: JSON.stringify(payload),
      signal: options.signal
    });
    const data = await resp.json();
    return data;
  } catch (e) {
    return { error: String(e) };
  }
}

if (newChatBtn) {
  newChatBtn.onclick = () => {
    archiveActiveChatToPrevious();

    const chat = makeChat('New Chat', []);
    chats = [chat, ...chats];
    activeChatId = chat.id;
    persistChats();
    renderChatList();
    renderReplyTranscript(true);
    chatStatus.textContent = 'Started a new chat';
  };
}

sendBtn.onclick = async () => {
  const pw = pwEl.value;
  if(!pw){ alert('Password required'); return; }
  const text = inputEl.value.trim();
  if(!text || chatInFlight) return;

  const active = getActiveChat();
  const chatContext = buildChatContextSnippet(active, 8, 1600, 400);
  const linkedUrls = extractHttpUrls(text);
  const explicitBrowsingRequest = linkedUrls.length > 0 && isExplicitBrowsingRequest(text);
  const retrievalBudget = {
    maxPrefetchUrls: 2,
    maxSummaryWords: 220
  };

  chatInFlight = true;
  sendBtn.disabled = true;
  chatStatus.textContent = 'Sending...';
  if (activeChatController) activeChatController.abort();
  activeChatController = new AbortController();

  appendMsg('You', text);
  inputEl.value = '';
  evidenceList.innerHTML = '<div class="small-muted">Worker deciding whether retrieval is needed...</div>';
  const startedAt = performance.now();

  let prefetchedContext = '';
  if (explicitBrowsingRequest) {
    try {
      prefetchedContext = await prefetchLinkedContext(text, pw);
    } catch (err) {
      appendMsg('System', `Could not pre-read linked content: ${err?.message || err}`);
    }
  }

  const contextBlock = chatContext ? `

CHAT CONTEXT (recent messages, oldest→newest):
${chatContext}` : '';
  const enrichedMessage = prefetchedContext
    ? `${text}${contextBlock}

Pre-read source material (use this first, then verify with retrieval):
${prefetchedContext}`
    : `${text}${contextBlock}`;

  const safeEnrichedMessage = hardTruncateText(enrichedMessage, 12000);
  const forceWebRequested = Boolean(prefetchedContext || isResearchIntentRequest(text));

  let res = await callWorker({
    password: pw,
    message: safeEnrichedMessage,
    forceWeb: forceWebRequested,
    researchMode: 'auto',
    retrievalBudget,
    liveInternet: true,
    requestedAt: new Date().toISOString(),
    styleProfile: 'grounded-brief-opinion',
    clientGuidance: {
      useChatContextOnly: true,
      requireGroundedResearchForRealWorldClaims: true,
      avoidOverconfidenceOnWeakEvidence: true
    }
  }, { signal: activeChatController.signal });

  const researchSignal = parseResearchNeededSignal(res.reply || '');
  if (researchSignal && !(res.evidence || []).length) {
    evidenceList.innerHTML = '<div class="small-muted">Worker requested research. Retrying with forced retrieval…</div>';
    res = await callWorker({
      password: pw,
      message: safeEnrichedMessage,
      forceWeb: true,
      researchMode: 'forced',
      retrievalBudget,
      liveInternet: true,
      requestedAt: new Date().toISOString(),
      styleProfile: 'grounded-brief-opinion',
      clientGuidance: {
        useChatContextOnly: true,
        requireGroundedResearchForRealWorldClaims: true,
        avoidOverconfidenceOnWeakEvidence: true
      }
    }, { signal: activeChatController.signal });
  }

  if (res.error) {
    appendMsg('Error', res.error);
    evidenceList.innerHTML = '<div class="small-muted">Retrieval failed.</div>';
    chatStatus.textContent = 'Last send failed';
    chatInFlight = false;
    sendBtn.disabled = false;
    return;
  }

  const repairedEvidence = await repairEvidence(res.evidence || [], pw);
  const synthesizedReply = await synthesizeGroundedAnswer({
    question: text,
    draftReply: res.reply || '',
    evidence: repairedEvidence,
    password: pw,
    signal: activeChatController.signal
  });
  const grounded = buildGroundedReply(synthesizedReply || res.reply || '', repairedEvidence);
  if (grounded.text) {
    const finalReply = grounded.metaHtml
      ? `${grounded.text}\n\n${grounded.metaHtml.replace(/<[^>]+>/g, '').trim()}`
      : grounded.text;
    appendMsg('Ashen', finalReply);
  }
  renderEvidence(repairedEvidence);
  if (res.tab && (!selectedTabId || res.tab.id === selectedTabId)) {
    displayTabContent(res.tab);
  }
  if (res.tabs) renderTabs(res.tabs);
  if (res.console) renderConsole(res.console);

  const elapsedMs = Math.round(performance.now() - startedAt);
  chatStatus.textContent = `Done in ${elapsedMs}ms`;
  chatInFlight = false;
  sendBtn.disabled = false;
};

openBtn.onclick = async () => {
  const pw = pwEl.value;
  const url = normalizeEmbeddableUrl(openUrl.value.trim());
  if(!pw){ alert('Password required'); return; }
  if(!url){ alert('Provide a URL'); return; }
  appendMsg('You', `open_tab ${url}`);
  const res = await callWorker({ password: pw, command: { type:'open_tab', url, fetchNow: true, summarizeAfter: true, words: 100 } });
  if (res.error) { appendMsg('Error', res.error); return; }
  if (res.tab) {
    appendMsg('System', `Opened: ${res.tab.finalUrl || res.tab.url}`);
    displayTabContent(res.tab);
  }
  if (res.tabs) renderTabs(res.tabs);
  if (res.console) renderConsole(res.console);
};

browseNowBtn.onclick = async () => {
  const pw = pwEl.value;
  const url = normalizeEmbeddableUrl(openUrl.value.trim());
  if(!pw){ alert('Password required'); return; }
  if(!url){ alert('Provide a URL'); return; }
  appendMsg('You', `browse_live ${url}`);
  const res = await callWorker({
    password: pw,
    command: { type:'open_tab', url, fetchNow: true, summarizeAfter: false },
    liveInternet: true,
    requestedAt: new Date().toISOString()
  });
  if (res.error) { appendMsg('Error', res.error); return; }
  if (res.tab) {
    selectedTabId = res.tab.id;
    displayTabContent(res.tab);
    ensureLivePolling();
    appendMsg('System', `Live browsing ${res.tab.finalUrl || res.tab.url}`);
  }
  if (res.tabs) renderTabs(res.tabs);
  if (res.console) renderConsole(res.console);
  ensureLivePolling();
};

refreshTabsBtn.onclick = async () => {
  const pw = pwEl.value;
  if(!pw){ alert('Password required'); return; }
  const res = await callWorker({ password: pw, command: { type:'list_tabs' } });
  if (res.error) { appendMsg('Error', res.error); return; }
  if (res.tabs) renderTabs(res.tabs);
  if (res.console) renderConsole(res.console);
};

function buildTabMetaKey(source) {
  if (!source) return '';
  const etag = source.etag || source.eTag || '';
  const hash = source.hash || source.contentHash || source.revisionHash || '';
  const updatedAt = source.updatedAt || source.lastFetchedAt || '';
  const status = source.status || '';
  return [etag, hash, updatedAt, status].join('|');
}

function buildTabRenderKey(tab) {
  if (!tab || !tab.id) return '';
  const embedUrl = tab?.embed?.embedUrl || '';
  return [
    buildTabMetaKey(tab),
    tab.lastFetchedAt || '',
    tab.summary || '',
    tab.content || '',
    tab.finalUrl || tab.url || '',
    embedUrl
  ].join('|');
}

function updateCachedTabKeys(tab) {
  if (!tab || !tab.id) return;
  const renderKey = buildTabRenderKey(tab);
  if (renderKey) renderedTabKeys.set(tab.id, renderKey);
  const metaKey = buildTabMetaKey(tab);
  if (metaKey) liveTabMetaKeys.set(tab.id, metaKey);
}

function extractTabUpdateMetadata(res) {
  if (!res || typeof res !== 'object') return null;
  return res.update || res.metadata || res.meta || res.tabMeta || res.tab_update || null;
}

function computeTabsSignature(tabs) {
  return (tabs || []).map((tab) => [
    tab.id,
    tab.title || '',
    tab.finalUrl || tab.url || '',
    tab.status || '',
    tab.lastFetchedAt || '',
    buildTabMetaKey(tab)
  ].join('::')).join('||');
}

function maybeRenderTabs(tabs) {
  const nextSignature = computeTabsSignature(tabs || []);
  if (nextSignature === lastTabsSignature) return false;
  renderTabs(tabs || []);
  return true;
}

function renderTabs(tabs) {
  lastTabs = tabs || [];
  lastTabsSignature = computeTabsSignature(lastTabs);
  tabsList.innerHTML = '';
  const frag = document.createDocumentFragment();

  for (const t of (tabs || []).slice().reverse()) {
    const div = document.createElement('div');
    div.className = 'tab';
    div.dataset.tabId = t.id;
    div.innerHTML = `
      <div style="font-weight:600;white-space:nowrap;overflow:hidden;text-overflow:ellipsis">${escapeHtml(t.title || t.finalUrl || t.url)}</div>
      <div class="small" style="white-space:nowrap;overflow:hidden;text-overflow:ellipsis">${escapeHtml(t.finalUrl || t.url)}</div>
    `;
    div.onclick = () => {
      selectedTabId = t.id;
      for (const el of tabsList.querySelectorAll('.tab')) el.classList.remove('active');
      div.classList.add('active');
      displayTabContent(t);
      renderTabsWindow();
      ensureLivePolling();
    };
    if (t.id === selectedTabId) div.classList.add('active');
    frag.appendChild(div);
  }

  tabsList.appendChild(frag);

  const selectedTab = lastTabs.find(t => t.id === selectedTabId);
  if (!selectedTab) {
    selectedTabId = lastTabs.length ? lastTabs[lastTabs.length - 1].id : null;
  }

  const normalizedSelection = lastTabs.find(t => t.id === selectedTabId) || null;
  if (normalizedSelection) {
    const selectedEl = tabsList.querySelector(`[data-tab-id="${CSS.escape(normalizedSelection.id)}"]`);
    if (selectedEl) selectedEl.classList.add('active');
    displayTabContent(normalizedSelection);
  } else {
    displayTabContent(null);
    tabContentDiv.textContent = 'No tabs available. Open a tab to begin.';
  }

  ensureLivePolling();
  renderTabsWindow();
}

function ensureTabsWindow(forceFocus = false) {
  if (tabsWindow && !tabsWindow.closed) {
    if (forceFocus) tabsWindow.focus();
    return tabsWindow;
  }

  tabsWindow = window.open('', 'moltbook-tabs-window', 'popup=yes,width=1400,height=900,resizable=yes,scrollbars=yes');
  if (!tabsWindow) {
    alert('Popup blocked. Allow popups for this site to open the large tabs window.');
    return null;
  }

  tabsWindow.document.write(`<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>MoltBook Tabs Viewer</title>
  <style>
    :root{--bg:#0f0f10;--panel:#111;--border:#232326;--accent:#2f6dd1;--muted:#9ca3af}
    html,body{height:100%;margin:0;background:var(--bg);color:#eee;font-family:Inter,system-ui,sans-serif}
    body{display:flex;flex-direction:column;padding:14px;gap:10px;box-sizing:border-box}
    .toolbar{display:flex;align-items:center;gap:8px;flex-wrap:wrap}
    .toolbar button{background:var(--accent);color:#fff;border:none;padding:8px 12px;border-radius:9px;cursor:pointer;font-weight:600}
    .toolbar .muted{font-size:12px;color:var(--muted)}
    #popupTabsStrip{display:flex;gap:8px;overflow:auto;padding:6px;background:#141418;border:1px solid var(--border);border-radius:10px 10px 0 0}
    .popup-tab{padding:10px 12px;border:1px solid #2a2d36;border-bottom:none;border-radius:10px 10px 0 0;background:#17171b;min-width:230px;cursor:pointer;display:flex;gap:8px;justify-content:space-between;align-items:flex-start}
    .popup-tab.active{background:#0b0b0b;border-color:var(--accent);box-shadow:inset 0 -2px 0 var(--accent)}
    .popup-tab-main{min-width:0;text-align:left}
    .popup-tab-close{background:#2a2d36;color:#dbe4ff;border:none;border-radius:999px;width:24px;height:24px;line-height:24px;text-align:center;cursor:pointer;font-size:14px;font-weight:700;flex:0 0 auto}
    .popup-tab-close:hover{background:#dc2626;color:#fff}
    .popup-tab .title,.popup-tab .url{white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
    .popup-tab .title{font-weight:600;margin-top:2px}
    .popup-tab .url{font-size:12px;color:#b9c3d4;margin-top:4px}
    #popupFrameWrap{flex:1;min-height:0;display:flex;flex-direction:column;border:1px solid var(--border);border-radius:0 0 12px 12px;overflow:hidden;background:#070707}
    #popupFrame{flex:1;border:none;width:100%;background:#000}
    #popupStatus{padding:8px 10px;font-size:12px;color:var(--muted);border-top:1px solid var(--border);background:#101216}
  </style>
</head>
<body>
  <div class="toolbar">
    <button id="popupRefresh">Refresh Tabs</button>
    <button id="popupOpenExternal">Open Current in New Tab</button>
    <button id="popupCloseCurrent">Close Current Tab</button>
    <span class="muted">Chrome-style strip + large viewer</span>
  </div>
  <div id="popupTabsStrip"></div>
  <div id="popupFrameWrap">
    <iframe id="popupFrame" referrerpolicy="no-referrer"></iframe>
    <div id="popupStatus">No tab selected.</div>
  </div>
</body>
</html>`);
  tabsWindow.document.close();
  tabsWindowReady = true;

  tabsWindow.addEventListener('beforeunload', () => {
    tabsWindowReady = false;
  });

  const refreshBtn = tabsWindow.document.getElementById('popupRefresh');
  const externalBtn = tabsWindow.document.getElementById('popupOpenExternal');
  const closeCurrentBtn = tabsWindow.document.getElementById('popupCloseCurrent');
  refreshBtn.onclick = () => refreshTabsBtn.click();
  externalBtn.onclick = () => {
    const selected = lastTabs.find(t => t.id === selectedTabId);
    const target = selected?.finalUrl || selected?.url;
    if (target) window.open(target, '_blank', 'noopener,noreferrer');
  };
  closeCurrentBtn.onclick = async () => {
    await closeSelectedTab(selectedTabId);
  };

  if (forceFocus) tabsWindow.focus();
  return tabsWindow;
}

function renderTabsWindow() {
  if (!tabsWindow || tabsWindow.closed || !tabsWindowReady) return;

  const popupDoc = tabsWindow.document;
  const strip = popupDoc.getElementById('popupTabsStrip');
  const frame = popupDoc.getElementById('popupFrame');
  const status = popupDoc.getElementById('popupStatus');
  if (!strip || !frame || !status) return;

  strip.innerHTML = '';
  const list = lastTabs.slice().reverse();
  list.forEach((tab) => {
    const item = popupDoc.createElement('div');
    item.className = `popup-tab ${tab.id === selectedTabId ? 'active' : ''}`;
    item.innerHTML = `
      <div class="popup-tab-main">
        <div class="title">${escapeHtml(tab.title || tab.finalUrl || tab.url || '(untitled)')}</div>
        <div class="url">${escapeHtml(tab.finalUrl || tab.url || '')}</div>
      </div>
      <button type="button" class="popup-tab-close" title="Close tab" aria-label="Close tab">×</button>
    `;

    item.querySelector('.popup-tab-main').onclick = () => {
      selectedTabId = tab.id;
      const selectedInMain = tabsList.querySelector(`[data-tab-id="${CSS.escape(tab.id)}"]`);
      for (const el of tabsList.querySelectorAll('.tab')) el.classList.remove('active');
      if (selectedInMain) selectedInMain.classList.add('active');
      const liveTab = lastTabs.find(t => t.id === tab.id) || tab;
      displayTabContent(liveTab);
      renderTabsWindow();
      ensureLivePolling();
    };

    item.querySelector('.popup-tab-close').onclick = (event) => {
      event.preventDefault();
      event.stopPropagation();
      closeSelectedTab(tab.id);
    };
    strip.appendChild(item);
  });

  const selected = lastTabs.find(t => t.id === selectedTabId) || null;
  if (!selected) {
    frame.removeAttribute('src');
    status.textContent = 'No tab selected.';
    return;
  }

  const targetUrl = selected.finalUrl || selected.url || '';
  if (targetUrl) {
    if (frame.src !== targetUrl) frame.src = targetUrl;
    status.textContent = `${selected.title || targetUrl} — ${targetUrl}`;
  } else {
    frame.removeAttribute('src');
    status.textContent = 'Selected tab has no URL yet.';
  }
}

openTabsWindowBtn.onclick = () => {
  const win = ensureTabsWindow(true);
  if (!win) return;
  renderTabsWindow();
};

function renderEvidence(evidence) {
  if (!evidence || !evidence.length) {
    evidenceList.innerHTML = '<div class="small-muted">No evidence found (worker attempted retrieval but found nothing). Try providing a clearer query or permit opening specific pages.</div>';
    return;
  }
  evidenceList.innerHTML = '';
  for (const e of evidence) {
    const normalizedUrl = normalizeEvidenceUrl(e.url || '');
    const el = document.createElement('div');
    el.className = 'evidence-item';
    el.innerHTML = `
      <div class="evidence-title">[${e.idx}] ${escapeHtml(e.title || '(no title)')}</div>
      <div class="small-muted">${escapeHtml(normalizedUrl || '(no url)')} — source: ${escapeHtml(e.sourceType || '(unknown)')}</div>
      <div style="height:6px"></div>
      <div>${escapeHtml((e.snippet || '').slice(0,800))}</div>
      <div style="height:8px"></div>
      <div style="font-style:italic;color:#cfc">${escapeHtml((e.summary || '').slice(0,800))}</div>
    `;
    evidenceList.appendChild(el);
  }
}

// render embed player if available (SoundCloud support)
function displayTabContent(tab) {
  if (!tab) { hideEmbed(); tabContentDiv.textContent = 'No tab selected.'; return; }

  updateCachedTabKeys(tab);

  // If embed metadata present (from worker), render the embed player
  if (tab.embed && tab.embed.type === 'soundcloud' && tab.embed.embedUrl) {
    showSoundCloudEmbed(tab.embed.embedUrl, tab);
    return;
  }

  showUniversalWebsiteEmbed(tab);

  const html = [];
  html.push(`Title: ${tab.title || '(no title)'}`);
  html.push(`URL: ${tab.finalUrl || tab.url}`);
  html.push(`Status: ${tab.status}`);
  if (tab.lastFetchedAt) html.push(`Last Fetched: ${tab.lastFetchedAt}`);
  if (tab.summary) html.push(`\n--- Summary ---\n${tab.summary}`);
  if (tab.content) {
    html.push(`\n--- Content (truncated) ---\n${tab.content.slice(0, 20000)}`);
  } else {
    html.push(`\n(No content fetched yet)`);
  }
  tabContentDiv.textContent = html.join("\n\n");
}

function normalizeEmbeddableUrl(url) {
  const trimmed = String(url || '').trim();
  if (!trimmed) return '';
  if (/^https?:\/\//i.test(trimmed)) return trimmed;
  if (trimmed.startsWith('//')) return `https:${trimmed}`;
  return `https://${trimmed}`;
}

function extractYouTubeEmbedUrl(rawUrl) {
  const normalized = normalizeEmbeddableUrl(rawUrl);
  if (!normalized) return '';
  try {
    const parsed = new URL(normalized);
    const host = parsed.hostname.toLowerCase();
    let videoId = '';

    if (host === 'youtu.be') {
      videoId = parsed.pathname.slice(1).split('/')[0];
    } else if (host.endsWith('youtube.com') || host.endsWith('youtube-nocookie.com')) {
      if (parsed.pathname === '/watch') {
        videoId = parsed.searchParams.get('v') || '';
      } else if (parsed.pathname.startsWith('/shorts/')) {
        videoId = parsed.pathname.split('/')[2] || '';
      } else if (parsed.pathname.startsWith('/embed/')) {
        videoId = parsed.pathname.split('/')[2] || '';
      }
    }

    if (!videoId) return '';
    return `https://www.youtube-nocookie.com/embed/${encodeURIComponent(videoId)}`;
  } catch (_err) {
    return '';
  }
}

function shouldPreferMirror(hostname) {
  const host = (hostname || '').toLowerCase();
  const blockedHosts = ['google.com', 'x.com', 'twitter.com'];
  return blockedHosts.some((h) => host === h || host.endsWith(`.${h}`));
}

function getInitialEmbedMode(targetUrl) {
  try {
    const parsed = new URL(targetUrl);
    const hostname = parsed.hostname.toLowerCase();
    const ytEmbed = extractYouTubeEmbedUrl(targetUrl);
    if (ytEmbed) {
      return {
        mode: 'youtube-embed',
        src: ytEmbed,
        note: 'Viewing: YouTube safe embed mode (nocookie player).'
      };
    }
    if (shouldPreferMirror(hostname)) {
      const mirror = toMirrorUrl(targetUrl);
      if (mirror) {
        return {
          mode: 'mirror',
          src: mirror,
          note: `Viewing: mirror mode (r.jina.ai) for ${hostname} (direct framing is commonly blocked).`
        };
      }
    }
  } catch (_err) {
    // fall through
  }

  return {
    mode: 'direct',
    src: targetUrl,
    note: `Viewing: direct website frame (${targetUrl})`
  };
}

function toMirrorUrl(url) {
  const normalized = normalizeEmbeddableUrl(url);
  if (!normalized) return '';
  try {
    const parsed = new URL(normalized);
    return `https://r.jina.ai/${parsed.protocol}//${parsed.host}${parsed.pathname}${parsed.search}`;
  } catch (_err) {
    return '';
  }
}

function showUniversalWebsiteEmbed(tab) {
  const targetUrl = normalizeEmbeddableUrl(tab.finalUrl || tab.url || '');
  if (!targetUrl) {
    hideEmbed();
    return;
  }

  if (cleanupUniversalEmbed) {
    cleanupUniversalEmbed();
    cleanupUniversalEmbed = null;
  }

  if (embedFallbackTimer) {
    clearTimeout(embedFallbackTimer);
    embedFallbackTimer = null;
  }

  embedContainer.innerHTML = '';
  embedContainer.style.display = 'block';

  const iframe = document.createElement('iframe');
  iframe.className = 'embed';
  iframe.referrerPolicy = 'no-referrer';

  let switched = false;
  let directLoaded = false;
  let isDirectMode = true;
  let userManuallySwitched = false;

  const note = document.createElement('div');
  note.className = 'embed-mode-note';
  const initialMode = getInitialEmbedMode(targetUrl);
  note.textContent = initialMode.note;

  const useDirect = (manual = false) => {
    if (manual) userManuallySwitched = true;
    isDirectMode = true;
    switched = false;
    directLoaded = false;
    iframe.src = targetUrl;
    note.textContent = `Viewing: direct website frame (${targetUrl})`;
  };
  const useMirror = (manual = false) => {
    if (manual) userManuallySwitched = true;
    const mirrorUrl = toMirrorUrl(targetUrl);
    if (!mirrorUrl) {
      note.textContent = 'Mirror mode unavailable for this URL. You can keep using Direct or Open.';
      return;
    }
    isDirectMode = false;
    switched = true;
    iframe.src = mirrorUrl;
    note.textContent = 'Viewing: mirror mode (r.jina.ai) for sites that block iframes.';
  };

  const useYouTubeEmbed = (manual = false) => {
    if (manual) userManuallySwitched = true;
    const ytEmbedUrl = extractYouTubeEmbedUrl(targetUrl);
    if (!ytEmbedUrl) {
      note.textContent = 'YouTube embed mode is unavailable for this URL.';
      return;
    }
    isDirectMode = false;
    switched = true;
    iframe.src = ytEmbedUrl;
    note.textContent = 'Viewing: YouTube safe embed mode (nocookie player).';
  };

  iframe.onload = () => {
    if (isDirectMode) {
      directLoaded = true;
    }
  };
  iframe.onerror = () => {
    if (isDirectMode && !switched) {
      useMirror();
    }
  };

  iframe.src = initialMode.src;
  isDirectMode = initialMode.mode === 'direct';
  switched = initialMode.mode !== 'direct';
  embedContainer.appendChild(iframe);

  const controls = document.createElement('div');
  controls.className = 'embed-controls';
  controls.innerHTML = `<button id="embedDirect">Direct</button><button id="embedMirror">Mirror</button><button id="embedYT">YouTube</button><button id="embedOpen">Open</button>`;
  embedContainer.appendChild(controls);
  embedContainer.appendChild(note);

  document.getElementById('embedDirect').onclick = () => useDirect(true);
  document.getElementById('embedMirror').onclick = () => useMirror(true);
  document.getElementById('embedYT').onclick = () => useYouTubeEmbed(true);
  document.getElementById('embedOpen').onclick = () => window.open(targetUrl, '_blank', 'noopener,noreferrer');

  if (initialMode.mode === 'youtube-embed') {
    useYouTubeEmbed();
  }

  // Auto-fallback improves "all websites" coverage for X-Frame-Options blocked pages.
  embedFallbackTimer = setTimeout(() => {
    if (!directLoaded && !switched && !userManuallySwitched) {
      useMirror();
    }
  }, 2200);

  cleanupUniversalEmbed = () => {
    if (embedFallbackTimer) {
      clearTimeout(embedFallbackTimer);
      embedFallbackTimer = null;
    }
    iframe.onload = null;
    iframe.onerror = null;
  };
}


function showSoundCloudEmbed(embedUrl, tab) {
  if (cleanupUniversalEmbed) {
    cleanupUniversalEmbed();
    cleanupUniversalEmbed = null;
  }

  embedContainer.innerHTML = '';
  embedContainer.style.display = 'block';
  tabContentDiv.textContent = '';
  // create iframe
  const iframe = document.createElement('iframe');
  iframe.className = 'embed';
  iframe.src = embedUrl + (embedUrl.includes('?') ? '&' : '?') + 'visual=true';
  iframe.setAttribute('allow', 'autoplay');
  iframe.setAttribute('id', 'sc-iframe-' + tab.id);
  embedContainer.appendChild(iframe);

  // inject widget script if not already present
  if (!window.SC) {
    const s = document.createElement('script');
    s.src = 'https://w.soundcloud.com/player/api.js';
    s.onload = ()=> { initSCWidget(iframe); };
    document.body.appendChild(s);
  } else {
    initSCWidget(iframe);
  }

  // simple controls
  const controls = document.createElement('div');
  controls.className = 'embed-controls';
  controls.innerHTML = `<button id="sc-play">Play</button><button id="sc-pause">Pause</button><button id="sc-seek">Seek +10s</button>`;
  embedContainer.appendChild(controls);

  document.getElementById('sc-play').onclick = ()=> { if (scWidget) scWidget.play(); };
  document.getElementById('sc-pause').onclick = ()=> { if (scWidget) scWidget.pause(); };
  document.getElementById('sc-seek').onclick = ()=> { if (scWidget) scWidget.seekTo && scWidget.seekTo((scWidget.getPosition?scWidget.getPosition():0) + 10000); };
}

function initSCWidget(iframe){
  try {
    scWidget = window.SC.Widget(iframe);
    // optional: listen to events
    scWidget.bind(window.SC.Widget.Events.PLAY, ()=> console.log('SC play'));
    scWidget.bind(window.SC.Widget.Events.PAUSE, ()=> console.log('SC pause'));
  } catch (e) { console.warn('SC Widget init failed', e); }
}

function hideEmbed() {
  if (cleanupUniversalEmbed) {
    cleanupUniversalEmbed();
    cleanupUniversalEmbed = null;
  }

  embedContainer.style.display = 'none';
  embedContainer.innerHTML = '';
  scWidget = null;
}

fetchTabBtn.onclick = async () => {
  if(!selectedTabId) { alert('Select a tab'); return; }
  const pw = pwEl.value; if(!pw) { alert('Password required'); return; }
  const res = await callWorker({ password: pw, command: { type:'fetch_tab', tabId: selectedTabId } });
  if (res.error) { appendMsg('Error', res.error); return; }
  if (res.tab) appendMsg('System', `Fetched: ${res.tab.finalUrl || res.tab.url}`);
  if (res.tabs) renderTabs(res.tabs);
  if (res.console) renderConsole(res.console);
  if (res.tab) displayTabContent(res.tab);
  renderTabsWindow();
};

summTabBtn.onclick = async () => {
  if(!selectedTabId) { alert('Select a tab'); return; }
  const pw = pwEl.value; if(!pw) { alert('Password required'); return; }
  const res = await callWorker({ password: pw, command: { type:'summarize_tab', tabId: selectedTabId, words: 120 }});
  if (res.error) { appendMsg('Error', res.error); return; }
  if (res.result) appendMsg('System', `Summary: ${res.result.summary}`);
  if (res.tab) displayTabContent(res.tab);
  if (res.tabs) renderTabs(res.tabs);
  if (res.console) renderConsole(res.console);
  renderTabsWindow();
};

async function closeSelectedTab(tabId = selectedTabId) {
  if(!tabId) { alert('Select a tab'); return; }
  const pw = pwEl.value; if(!pw) { alert('Password required'); return; }
  const res = await callWorker({ password: pw, command: { type:'close_tab', tabId }});
  if (res.error) { appendMsg('Error', res.error); return; }
  appendMsg('System', 'Closed the selected tab.');
  if (Array.isArray(res.tabs)) {
    renderTabs(res.tabs);
  } else {
    const listRes = await callWorker({ password: pw, command: { type:'list_tabs' } });
    if (listRes.error) {
      appendMsg('Error', listRes.error);
    } else {
      renderTabs(listRes.tabs || []);
      if (listRes.console) renderConsole(listRes.console);
    }
  }
  if (res.console) renderConsole(res.console);
  renderTabsWindow();
}

closeTabBtn.onclick = async () => {
  await closeSelectedTab();
};

liveMode.onchange = () => {
  if (liveMode.checked) {
    appendMsg('System', 'Live internet mode enabled. Selected tab will auto-refresh.');
  } else {
    appendMsg('System', 'Live internet mode paused.');
  }
  ensureLivePolling();
};

liveSeconds.onchange = () => {
  ensureLivePolling();
};

function ensureLivePolling() {
  if (liveTimer) {
    clearTimeout(liveTimer);
    liveTimer = null;
  }
  if (!liveMode.checked || !selectedTabId) return;

  const now = Date.now();
  const waitMs = Math.max(0, liveBackoffUntil - now);
  liveTimer = setTimeout(refreshSelectedTab, waitMs);
}

function getLiveBaseIntervalMs() {
  // hard floor of 30s avoids accidental rapid polling that can look abusive.
  const requestedSeconds = Number(liveSeconds.value) || 60;
  const safeSeconds = Math.max(30, requestedSeconds);
  return safeSeconds * 1000;
}

function isRateLimitLikeError(msg) {
  const text = String(msg || '').toLowerCase();
  return /429|too many requests|rate limit|ddos|captcha|temporarily blocked/.test(text);
}

function scheduleNextLiveRefresh() {
  if (liveTimer) {
    clearTimeout(liveTimer);
    liveTimer = null;
  }
  if (!liveMode.checked || !selectedTabId) return;

  const now = Date.now();
  const base = getLiveBaseIntervalMs();
  const jitter = Math.floor(base * (0.15 * Math.random()));
  const adaptive = Math.min(base * 8, base * Math.pow(2, liveFailureCount));
  const earliest = Math.max(now + adaptive + jitter, liveBackoffUntil);
  liveTimer = setTimeout(refreshSelectedTab, Math.max(0, earliest - now));
}

async function refreshSelectedTab() {
  if (!selectedTabId || !liveMode.checked) return;
  if (document.hidden) {
    scheduleNextLiveRefresh();
    return;
  }
  if (liveInFlight) return;

  const pw = pwEl.value;
  if (!pw) {
    scheduleNextLiveRefresh();
    return;
  }

  liveInFlight = true;
  try {
    const checkRes = await callWorker({
      password: pw,
      command: { type:'check_tab_update', tabId: selectedTabId },
      liveInternet: true,
      requestedAt: new Date().toISOString()
    });

    if (checkRes.error) {
      liveFailureCount += 1;
      if (isRateLimitLikeError(checkRes.error)) {
        const cooldownMs = Math.min(30 * 60 * 1000, getLiveBaseIntervalMs() * 12);
        liveBackoffUntil = Date.now() + cooldownMs;
        appendMsg('System', `Live refresh paused due to remote rate limiting. Retrying in ~${Math.ceil(cooldownMs / 60000)} min.`);
      } else {
        appendMsg('System', `Live refresh failed: ${checkRes.error}`);
      }
      scheduleNextLiveRefresh();
      return;
    }

    if (checkRes.console) renderConsole(checkRes.console);

    const meta = extractTabUpdateMetadata(checkRes) || {};
    const metadataKey = buildTabMetaKey(meta);
    const priorMetadataKey = liveTabMetaKeys.get(selectedTabId) || '';
    const metadataChanged = metadataKey ? metadataKey !== priorMetadataKey : false;
    const hasChanged = typeof meta.changed === 'boolean'
      ? meta.changed
      : (metadataChanged || /changed|updated/i.test(String(meta.status || '')));

    if (!hasChanged) {
      if (metadataKey) liveTabMetaKeys.set(selectedTabId, metadataKey);
      liveFailureCount = 0;
      liveBackoffUntil = 0;
      scheduleNextLiveRefresh();
      return;
    }

    const fetchRes = await callWorker({
      password: pw,
      command: { type:'fetch_tab', tabId: selectedTabId },
      liveInternet: true,
      requestedAt: new Date().toISOString()
    });

    if (fetchRes.error) {
      liveFailureCount += 1;
      if (isRateLimitLikeError(fetchRes.error)) {
        const cooldownMs = Math.min(30 * 60 * 1000, getLiveBaseIntervalMs() * 12);
        liveBackoffUntil = Date.now() + cooldownMs;
        appendMsg('System', `Live refresh paused due to remote rate limiting. Retrying in ~${Math.ceil(cooldownMs / 60000)} min.`);
      } else {
        appendMsg('System', `Live refresh failed: ${fetchRes.error}`);
      }
      scheduleNextLiveRefresh();
      return;
    }

    liveFailureCount = 0;
    liveBackoffUntil = 0;

    if (fetchRes.tab) {
      const nextRenderKey = buildTabRenderKey(fetchRes.tab);
      const previousRenderKey = renderedTabKeys.get(fetchRes.tab.id) || '';
      if (!nextRenderKey || nextRenderKey !== previousRenderKey) {
        displayTabContent(fetchRes.tab);
      } else {
        updateCachedTabKeys(fetchRes.tab);
      }
    }
    if (fetchRes.tabs) maybeRenderTabs(fetchRes.tabs);
    if (fetchRes.console) renderConsole(fetchRes.console);
    scheduleNextLiveRefresh();
  } catch (err) {
    liveFailureCount += 1;
    appendMsg('System', `Live refresh request failed: ${err?.message || err}`);
    scheduleNextLiveRefresh();
  } finally {
    liveInFlight = false;
  }
}


document.addEventListener('visibilitychange', () => {
  if (!liveMode.checked) return;
  ensureLivePolling();
});

function renderConsole(entries) {
  consoleDiv.innerHTML = '';
  for (const e of (entries || []).slice(-200).reverse()) {
    const line = document.createElement('div');
    line.innerHTML = `<span class="small">[${escapeHtml(e.ts)}]</span> <b>${escapeHtml(e.level)}</b> ${escapeHtml(e.msg)}`;
    consoleDiv.appendChild(line);
  }
  consoleDiv.scrollTop = consoleDiv.scrollHeight;
}


if (toggleDrawerBtn) {
  toggleDrawerBtn.onclick = () => rightDrawer.classList.toggle('closed');
}
if (closeDrawerBtn) {
  closeDrawerBtn.onclick = () => rightDrawer.classList.add('closed');
}

inputEl.addEventListener('keydown', (event) => {
  if ((event.ctrlKey || event.metaKey) && event.key === 'Enter') {
    event.preventDefault();
    sendBtn.click();
  }
});

initializeChats();

// initial load
(async ()=> {
  const res = await callWorker({ password: pwEl.value||"", command: { type:'list_tabs' } });
  if (res && res.tabs) renderTabs(res.tabs);
  if (res && res.console) renderConsole(res.console);
})();
</script>
</body>
</html>
